//
//  TunnelMonitor.swift
//  TunnelMonitorKit
// 
//  Created by Chris J on 20/03/2022.
//  Copyright Â© 2022 Chris Janusiewicz. Distributed under the MIT License.
//

import Foundation
import NetworkExtension
import UIKit

/// Responsible for communication with the an NEPacketTunnelProvider or NEAppProxyProvider. Continuously sends status
/// update requests to the network extension, such that the extension can use these requests to notify the host app of
/// any changes of state. The session to be monitored must be set using setSession after the session has connected.
open class TunnelMonitor {

    private var session: TMTunnelProviderSession?
    private var pollTimer: Timer?
    private var stateUpdateHandler: ((Codable) -> Void)?

    public init() { }

    /// Sets the session to be monitored. The session must be set before it can be monitored.
    /// - Parameter session: The session to be monitored.
    public func setSession(session: TMTunnelProviderSession?) {
        self.session = session
    }

    /// Sets the update handler which is invoked any time the state of the monitored session changes.
    public func setUpdateHandler(_ handler: @escaping (Codable) -> Void) {
        self.stateUpdateHandler = handler
    }

    /// Starts monitoring the current NETunnelProviderSession using status requests generated by the given request
    /// builder at the specified interval.
    /// - Parameters:
    ///   - requestBuilder: The block responsible for constructing a status request
    ///   - interval: The interval at which to request status updates
    public func startMonitoring<T: Codable>(
        session: TMTunnelProviderSession? = nil,
        withRequestBuilder requestBuilder: @escaping () -> T,
        pollInterval interval: TimeInterval = 1.0
    ) {
        if let session = session {
            self.session = session
        }
        pollTimer?.invalidate()
        pollTimer = Timer.scheduledTimer(
            withTimeInterval: interval,
            repeats: true
        ) { [weak self] _ in
            self?.sendMessage(message: requestBuilder()) { data in
                self?.stateUpdateHandler?(data)
            }
        }
    }

    /// Stops requesting status updates
    public func stopMonitoring() {
      pollTimer?.invalidate()
    }


    /// Sends a generic message to the session.
    /// - Parameters:
    ///   - message: The message to be encoded and sent to the session.
    ///   - responseHandler: Completion block to be invoked when a response is received.
    public func sendMessage<T: Codable>(message: T, responseHandler: ResponseCompletion) {
        // TODO: throw errors instead of consecutive guards
        guard let session = session else {
            log(.warning, "Unable to send message to extension - session is nil")
            return
        }
        guard session.status == .connected else {
            log(.warning, "Unable to send message to extension - incorrect status: \(session.status)")
            return
        }
        guard let container = MessageContainer.make(message: message) else {
            log(.error, "Unable to send message to extension - error serializing contents of message: \(message)")
            return
        }

        do {
            let messageData = try JSONEncoder().encode(container)
            let sendDate = Date()
            try session.sendProviderMessage(messageData) { data in
                let rtt = Date().timeIntervalSince(sendDate)
                log(.info, "Response received, rtt: \(String(format: "%.1f", rtt * 1000))ms")
                responseHandler?(data)
            }
        } catch {
            log(.error, "Failed to send message to extension: \(error)")
            return
        }
    }
}
