//
//  TunnelMonitor.swift
//  TunnelMonitorKit
// 
//  Created by Chris J on 20/03/2022.
//  Copyright Â© 2022 Chris Janusiewicz. Distributed under the MIT License.
//

import Foundation
import NetworkExtension

/// Responsible for communication with the an NEPacketTunnelProvider or NEAppProxyProvider. Continuously sends status
/// update requests to the network extension, such that the extension can use these requests to notify the host app of
/// any changes of state. The session to be monitored must be set using setSession after the session has connected.
open class TunnelMonitor {

    private var session: TMTunnelProviderSession?
    private var pollTimer: Timer?
    private var stateUpdateHandler: ((Codable) -> Void)?

    public init() { }

    /// Sets the session to be monitored. The session must be set before it can be monitored.
    /// - Parameter session: The session to be monitored.
    public func setSession(session: TMTunnelProviderSession?) {
        self.session = session
    }

    /// Sets the update handler which is invoked any time the state of the monitored session changes.
    public func setUpdateHandler(_ handler: @escaping (Codable) -> Void) {
        self.stateUpdateHandler = handler
    }

    /// Starts monitoring the current NETunnelProviderSession using status requests generated by the given request
    /// builder at the specified interval.
    /// - Parameters:
    ///   - requestBuilder: The block responsible for constructing a status request
    ///   - interval: The interval at which to request status updates
    public func startMonitoring<T: Codable>(
        session: TMTunnelProviderSession? = nil,
        withRequestBuilder requestBuilder: @escaping () -> T,
        pollInterval interval: TimeInterval = 1.0
    ) {
        if let session = session {
            self.session = session
        }

        let timerBlock = { [weak self] (_: Timer) in
            do {
                try self?.sendMessage(message: requestBuilder()) { data in
                    self?.stateUpdateHandler?(data)
                }
            } catch {
                log(.error, "Error sending message: \(error)")
            }
        }

        pollTimer?.invalidate()
        // Schedule a timer to invoke the block repeatedly, and execute it once immediately
        let timer = Timer.scheduledTimer(
            withTimeInterval: interval,
            repeats: true,
            block: timerBlock
        )
        timerBlock(timer)

        pollTimer = timer
    }

    /// Stops requesting status updates
    public func stopMonitoring() {
        pollTimer?.invalidate()
    }

    /// Sends a generic message to the session.
    /// - Parameters:
    ///   - message: The message to be encoded and sent to the session.
    ///   - responseHandler: Completion block to be invoked when a response is received.
    public func sendMessage<T: Codable>(message: T, responseHandler: ResponseCompletion) throws {
        guard let session = session else { throw TMCommunicationError.invalidExtension }
        guard session.status == .connected else { throw TMCommunicationError.invalidState(session.status) }

        do {
            let container = try MessageContainer.make(message: message)
            let messageData = try JSONEncoder().encode(container)
            let sendDate = Date()
            try session.sendProviderMessage(messageData) { data in
                let rtt = Date().timeIntervalSince(sendDate)
                log(.info, "Response received, rtt: \(String(format: "%.1f", rtt * 1000))ms")
                responseHandler?(data)
            }
        } catch {
            // Rethrow as TMCommunicationError wrapping the original error
            if error is EncodingError {
                throw TMCommunicationError.containerSerializationError(encodeError: error)
            }
            throw TMCommunicationError.sendFailure(error: error)
        }
    }
}

/// Contains information about why communication with tunnel failed
public enum TMCommunicationError: Error {

    /// The extension is not in a state in which it can be communicated with
    case invalidState(NEVPNStatus)

    /// The manager connection instance could not be cast to a NETunnelProviderSession or is nil
    case invalidExtension

    /// The response received was nil
    case nilResponse

    /// The response could not be decoded
    case responseDecodingError(decodeError: Error)

    /// The outgoing message could not be serialized
    case containerSerializationError(encodeError: Error)

    /// Generic error sending message
    case sendFailure(error: Error)
}

extension TMCommunicationError: CustomStringConvertible {
    /// Provides a meaningful description for each error type
    public var description: String {
        switch self {
        case .invalidState(let status):
            return "The extension is not in a state in which it can be communicated with: \(status)."
        case .invalidExtension:
            return "The extension is of incorrect type or nil - it could not be cast to a NETunnelProviderSession."
        case .nilResponse:
            return "The extension response was nil."
        case .responseDecodingError(let error):
            return "Failed to decode response: \(error)"
        case .containerSerializationError(let error):
            return "Failed to serialize outgoing message: \(error)"
        case .sendFailure(let error):
            return "Failed to send message: \(error)"
        }
    }
}
