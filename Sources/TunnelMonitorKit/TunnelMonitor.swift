//
//  TunnelMonitor.swift
//  TunnelMonitorKit
// 
//  Created by Chris J on 20/03/2022.
//  Copyright Â© 2022 Chris Janusiewicz. Distributed under the MIT License.
//

import Foundation
import NetworkExtension
import UIKit

/// Responsible for communication with the an NEPacketTunnelProvider or NEAppProxyProvider. Continuously sends status
/// update requests to the network extension, such that the extension can use these requests to notify the host app of
/// any changes of state. The session to be monitored must be set using setSession after the session has connected.
open class TunnelMonitor {

    private var session: TMTunnelProviderSession?
    private var pollTimer: Timer?

    public init() { }

    /// Sets the session to be monitored. The session must be set before it can be monitored.
    /// - Parameter session: The session to be monitored.
    public func setSession(session: TMTunnelProviderSession?) {
        self.session = session
    }

    /// Starts monitoring the current NETunnelProviderSession using status requests generated by the given request
    /// builder at the specified interval.
    /// - Parameters:
    ///   - requestBuilder: The block responsible for constructing a status request
    ///   - interval: The interval at which to request status updates
    public func startMonitoring<T: Codable>(
        session: TMTunnelProviderSession? = nil,
        withRequestBuilder requestBuilder: @escaping () -> T,
        pollInterval interval: TimeInterval = 1.0
    ) {
        if let session = session {
            self.session = session
        }
        pollTimer?.invalidate()
        pollTimer = Timer.scheduledTimer(
            withTimeInterval: interval,
            repeats: true
        ) { [weak self] _ in
            // TODO: perform request here
            self?.sendMessage(message: requestBuilder()) { data in
                print("response")
            }
        }
    }

    /// Stops requesting status updates
    public func stopMonitoring() {
      pollTimer?.invalidate()
    }


    /// Sends a generic message to the session.
    /// - Parameters:
    ///   - message: The message to be encoded and sent to the session.
    ///   - responseHandler: Completion block to be invoked when a response is received.
    public func sendMessage<T: Codable>(message: T, responseHandler: ResponseCompletion) {
        // TODO: throw errors instead of consecutive guards
        guard let session = session else {
            log(.warning, "Unable to send message to extension - session is nil")
            return
        }
        guard session.status == .connected else {
            log(.warning, "Unable to send message to extension - incorrect status: \(session.status)")
            return
        }
        guard let container = MessageContainer.make(message: message) else {
            log(.error, "Unable to send message to extension - error serializing contents of message: \(message)")
            return
        }

        do {
            let messageData = try JSONEncoder().encode(container)
            let sendDate = Date()
            try session.sendProviderMessage(messageData) { data in
                let rtt = Date().timeIntervalSince(sendDate)
                log(.info, "Response received, rtt: \(String(format: "%.1f", rtt * 1000))ms")
                responseHandler?(data)
            }
        } catch {
            log(.error, "Failed to send message to extension: \(error)")
            return
        }
    }
}

/// A base class allowing native and mock sessions to be used interchangebly.
public class TMTunnelProviderSession {

    /// This method returns immediately after starting the process of connecting the tunnel.
    /// - Parameter options: A dictionary containing options to be passed to the Tunnel Provider extension.
    func startTunnel(options: [String: Any]?) throws { }

    /// This method returns immediately after starting the process of disconnecting the tunnel.
    func stopTunnel() { }

    /// Attempts to send a message to the tunnel session.
    /// - Parameters:
    ///   - message: The message to be sent
    ///   - responseHandler: Completion handler invoked with the response, if one is received.
    func sendProviderMessage(_ message: Data, responseHandler: ResponseCompletion) throws { }

    /// Returns the current session status.
    var status: NEVPNStatus { return .invalid }

}

/// A wrapper around a real NETunnelProviderSession.
public class TMTunnelProviderSessionNative: TMTunnelProviderSession {

    private let nativeSession: NETunnelProviderSession

    public init(nativeSession: NETunnelProviderSession) {
        self.nativeSession = nativeSession
    }

    override public var status: NEVPNStatus {
        return nativeSession.status
    }

    override public func stopTunnel() {
        nativeSession.stopTunnel()
    }

    override public func startTunnel(options: [String: Any]?) throws {
        try nativeSession.startTunnel(options: options)
    }

    override public func sendProviderMessage(_ message: Data, responseHandler: ResponseCompletion) throws {
        try nativeSession.sendProviderMessage(message, responseHandler: responseHandler)
    }
}

/// A mock tunnel provider session.
public class TMTunnelProviderSessionMock: TMTunnelProviderSession {

    public let mockMessageRouter = MessageRouter()
    public var statusToReturn = NEVPNStatus.invalid


    override public var status: NEVPNStatus {
        return statusToReturn
    }

    override public func stopTunnel() {
        statusToReturn = NEVPNStatus.disconnected
    }

    override public func startTunnel(options: [String: Any]?) throws {
        statusToReturn = NEVPNStatus.connected
    }

    override public func sendProviderMessage(_ message: Data, responseHandler: ResponseCompletion) throws {
        guard
            statusToReturn == .connected,
            let messageContainer = MessageContainer.decode(from: message)
        else { return }
        mockMessageRouter.handle(message: messageContainer) { data in
            responseHandler?(data)
        }
    }

}
